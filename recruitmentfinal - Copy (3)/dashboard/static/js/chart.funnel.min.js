(function(global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('chart.js')) :
        typeof define === 'function' && define.amd ? define(['chart.js'], factory) :
        (factory(global.Chart));
}(this, (function(Chart) {
    'use strict';

    Chart = Chart && Chart.hasOwnProperty('default') ? Chart['default'] : Chart;

    const helpers = Chart.helpers;
    const defaults = Chart.defaults;

    defaults.funnel = {
        animation: {
            animateRotate: true,
            animateScale: true
        },
        hover: {
            mode: 'label'
        },
        responsive: true,
        legend: {
            display: false,
            position: 'top',
            fullWidth: true,
            labels: {
                generateLabels: function(chart) {
                    const data = chart.data;
                    if (data.labels.length && data.datasets.length) {
                        return data.labels.map(function(label, i) {
                            const meta = chart.getDatasetMeta(0);
                            const ds = data.datasets[0];
                            const arc = meta.data[i];
                            const custom = arc.custom || {};
                            const getValueAtIndexOrDefault = helpers.getValueAtIndexOrDefault;
                            const arcOpts = chart.options.elements.arc;
                            const fill = custom.backgroundColor ? custom.backgroundColor : getValueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
                            const stroke = custom.borderColor ? custom.borderColor : getValueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
                            const bw = custom.borderWidth ? custom.borderWidth : getValueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);

                            return {
                                text: label,
                                fillStyle: fill,
                                strokeStyle: stroke,
                                lineWidth: bw,
                                hidden: isNaN(ds.data[i]) || meta.data[i].hidden,
                                index: i
                            };
                        });
                    }
                    return [];
                }
            }
        },
        tooltips: {
            callbacks: {
                title: function() {
                    return '';
                },
                label: function(tooltipItem, data) {
                    return data.labels[tooltipItem.index] + ': ' + data.datasets[0].data[tooltipItem.index];
                }
            }
        }
    };

    Chart.controllers.funnel = Chart.DatasetController.extend({
        dataElementType: Chart.elements.Rectangle,

        linkScales: function() {
            // No scales for funnel charts
        },

        update: function(reset) {
            const me = this;
            const chart = me.chart;
            const chartArea = chart.chartArea;
            const opts = chart.options;
            const arcOpts = opts.elements.arc;
            const availableWidth = chartArea.right - chartArea.left;
            const availableHeight = chartArea.bottom - chartArea.top;
            let x = 0;
            const meta = me.getMeta();
            const dataset = me.getDataset();
            const data = dataset.data;
            let curWidth = 0;
            let halfCurWidth = 0;

            meta.total = 0;
            for (let i = 0; i < data.length; i++) {
                meta.total += Math.abs(data[i]);
            }

            for (let i = 0; i < meta.data.length; i++) {
                const element = meta.data[i];
                const custom = element.custom || {};
                const dataAtIndex = me.getDataset().data[i];

                halfCurWidth = availableWidth / meta.total * dataAtIndex / 2;

                helpers.extend(element, {
                    _datasetIndex: me.index,
                    _index: i,
                    _model: {
                        type: 'rectangle',
                        x: chartArea.left + availableWidth / 2,
                        y: chartArea.top + availableHeight / data.length * (i + 0.5),
                        backgroundColor: custom.backgroundColor ? custom.backgroundColor : me.getValueAtIndexOrDefault(dataAtIndex, 'backgroundColor'),
                        borderSkipped: 'top',
                        borderColor: custom.borderColor ? custom.borderColor : me.getValueAtIndexOrDefault(dataAtIndex, 'borderColor'),
                        borderWidth: custom.borderWidth ? custom.borderWidth : me.getValueAtIndexOrDefault(dataAtIndex, 'borderWidth'),
                        label: custom.label ? custom.label : me.chart.data.labels[i],
                        width: availableWidth / meta.total * dataAtIndex,
                        height: availableHeight / data.length
                    },
                    _view: element._model
                });
                x += availableWidth / meta.total * dataAtIndex / 2;
                element.pivot();
            }
            me.removeOrHide(meta.data, 0, meta.data.length, reset);
        },

        draw: function(ease) {
            const easingDecimal = ease || 1;
            helpers.each(this.getMeta().data, function(element, index) {
                element.transition(easingDecimal).draw();
            });
        },

        setHoverStyle: function(element) {
            const dataset = this.chart.data.datasets[element._datasetIndex];
            const custom = element.custom || {};
            const index = element._index;
            const model = element._model;

            model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.getValueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(element.getStyle().backgroundColor));
            model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.getValueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(element.getStyle().borderColor));
            model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.getValueAtIndexOrDefault(dataset.hoverBorderWidth, index, element.getStyle().borderWidth);
        },

        removeHoverStyle: function(element) {
            const dataset = this.chart.data.datasets[element._datasetIndex];
            const custom = element.custom || {};
            const index = element._index;
            const model = element._model;
            const arcOpts = this.chart.options.elements.arc;

            model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.getValueAtIndexOrDefault(dataset.backgroundColor, index, arcOpts.backgroundColor);
            model.borderColor = custom.borderColor ? custom.borderColor : helpers.getValueAtIndexOrDefault(dataset.borderColor, index, arcOpts.borderColor);
            model.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.getValueAtIndexOrDefault(dataset.borderWidth, index, arcOpts.borderWidth);
        }
    });

    // Register the funnel chart type
    Chart.defaults.funnel = Chart.defaults.pie;
    Chart.controllers.funnel = Chart.controllers.funnel;

})));
